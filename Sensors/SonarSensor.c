#pragma config(Hubs,  S1, HTMotor,  HTMotor,  none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     IRSeeker,       sensorHiTechnicIRSeeker1200)
#pragma config(Sensor, S3,     light,          sensorLightActive)
#pragma config(Sensor, S4,     sonar,          sensorSONAR)
#pragma config(Motor,  motorA,          gripperMotor,  tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C1_1,     rightMotor,    tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     leftMotor,     tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     armMotor,      tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C2_2,     spinnerMotor,  tmotorTetrix, openLoop, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*+++++++++++++++++++++++++++++++++++++++++++++| Notes |++++++++++++++++++++++++++++++++++++++++++++++
Gripperbot IR - Preload Score Routine

This program is designed for the the Virtual World 'FTC Block Party!'
It is designed to score the preload block in the red box with the IR beacon.
Gripperbot (IR) starting at start point R3 should be used for this program.

Start at R3 with Gripperbot
1) Move forward until on the red line
2) Turn left until sonar is less than 75 (far wall)
3) Line track to center of the red line
4) Turn towards boxes
5) Raise Arm
6) Seek IR beacon
7) Move forward to boxes (tracking IR)
8) Score object

Robot Model(s): TETRIX Gripperbot (IR) (Virtual Worlds)

[I/O Port]          [Name]              [Type]                [Description]
Motor Port A        gripperMotor        NXT Motor             Gripper motor
Motor Port D        rightMotor          TETRIX Motor          Right side motor
Motor Port E				leftMotor						TETRIX Motor					Left side motor
Motor Port F 				armMotor						TETRIX Motor					Arm motor
Motor Port G 				spinnerMotor				TETRIX Motor 					Spinner motor

Sensor Port 2				IRSeeker						IRSeeker 1200					HiTechnic IRSeeker 1200
Sensor Port 3				light   						Light Sensor					NXT Light Sensor (Active)
Sensor Port 4				sonar 							Sonar Sensor					NXT Sonar Sensor

----------------------------------------------------------------------------------------------------*/

task main()
{
	//Variables for the line-tracking threshold value
	// and to determine which side of the robot the IR beacon will be
	int threshold = 55;
	int targetIR;

	//Sets the initial value of the IR beacon relative to the robot's start position
	//This will be used later when the robot has to track the IR beacon
	if(SensorValue[IRSeeker] < 6) //To the left of the robot
	{
		targetIR = 5;
	}
	else //To the right of the robot
	{
		targetIR = 4;
	}

	//Step 1
	//Move forward until on the red line

	//Clear the encoder value of the right motor
	nMotorEncoder[rightMotor] = 0;
	//While the right encoder is reading less than 1000 counts
	while(nMotorEncoder[rightMotor] < 1000)
	{
		//Move the robot forward
		motor[leftMotor]  = 50;
		motor[rightMotor] = 50;
	}
	//Stop motors
	motor[leftMotor]  = 0;
	motor[rightMotor] = 0;

	//Step 2
	//Turn left until sonar is less than 75 (far wall)

	//While the sonar sensor is reading a value greater than 75
	while(SensorValue[sonar] > 75)
	{
		//Turn the robot to the left (until robot is straddling the red line)
		motor[leftMotor] 	= -50;
		motor[rightMotor] =  50;
	}
	motor[leftMotor]  = 0;
	motor[rightMotor] = 0;

	//Step 3
	//Line track to center of the red line

	//While the sonar sensor is reading a value greater than or equal to 47
	//while(SensorValue[sonar] >= 47)
//	{
		//Keep line tracking forward
		if(SensorValue[light] < threshold) //Sees red (line)
		{
			motor[leftMotor]  =  40;
			motor[rightMotor] =  60;
		}

		else //Sees grey (tile)
		{
			motor[leftMotor]  =  60;
			motor[rightMotor] =  40;
		}
	//}
	//Stop motors
	motor[leftMotor]  = 0;
	motor[rightMotor] = 0;

	//Step 4
	//Turn towards boxes

	//Quickly turn right, (away from wall) until sonar sensor reads a value greater than 100
	while(SensorValue[sonar] < 100)
	{
		motor[leftMotor] = 100;
		motor[rightMotor] = -100;
	}
	//Stop motors
	motor[leftMotor] = 0;
	motor[rightMotor] = 0;

	//Slowly keep turning to the right until the sonar value is less than or equal to 78
	//This should roughly 'square' the robot to the boxes
	while(SensorValue[sonar] >= 78)
	{
		motor[leftMotor] = 30;
		motor[rightMotor] = -30;
	}
	//Stop motors
	motor[leftMotor] = 0;
	motor[rightMotor] = 0;

	//Step 5
	//Raise Arm

	//Clear the encoder value of the arm
	nMotorEncoder[armMotor] = 0;

	//While the arm's encoder value is less than 450
	while(nMotorEncoder[armMotor] < 450)
	{
		//Keep raising the arm
		motor[armMotor] = 100;
	}
	//Stop raising the arm
	motor[armMotor] = 0;

	//Step 6
	//Seek IR beacon

	// While the IR Seeker is not equal to the value determined
	// by the intial position of the IR beacon
	while(SensorValue[IRSeeker] != targetIR)
	{
		//If the beacon is to the left of the robot, turn left
		if(SensorValue[IRSeeker] < targetIR && SensorValue[IRSeeker] != 0)
		{
			//Turn left
			motor[leftMotor] =   -50;
			motor[rightMotor] = 50;
		}

		//If the beacon is to the right of the robot, turn right
		else if(SensorValue[IRSeeker] > targetIR)
		{
			//Turn right
			motor[leftMotor] = 50;
			motor[rightMotor] = -50;
		}

		//If the beacon cannot be found (value of 0)
		else
		{
			// Spin in place to the right and find the beacon
			while(SensorValue[IRSeeker] == 0)
			{
				motor[leftMotor]  =  100;
				motor[rightMotor] = -100;
			}
			motor[rightMotor] =  0;
			motor[leftMotor]  =  0;
		}
	}
	//Stop the motors
	motor[leftMotor]  = 0;
	motor[rightMotor] = 0;

	//Step 7
	//Move forward to boxes (tracking IR)

	//If the sensor is to the right of the robot
	if(targetIR == 4)
	{
		//Use the sonar sensor to get close to the box
		while(SensorValue[sonar] > 20)
		{
			//Constantly adjust to keep the IR beacon in line with the robot
			if(SensorValue[IRSeeker] < targetIR && SensorValue[IRSeeker] != 0)
			{
				//Turn left
				motor[leftMotor] =   -50;
				motor[rightMotor] = 50;
			}

			else if(SensorValue[IRSeeker] > targetIR)
			{
				//Turn right
				motor[leftMotor] = 50;
				motor[rightMotor] = -50;
			}

			else if (SensorValue[IRSeeker] == targetIR)
			{
				motor[leftMotor] = 60;
				motor[rightMotor]= 60;
			}

			else
			{
				// Find the beacon
				while(SensorValue[IRSeeker] == 0)
				{
					motor[leftMotor]  =  100;
					motor[rightMotor] = -100;
				}

				motor[rightMotor] =  0;
				motor[leftMotor]  =  0;
			}
		}
	}

	//If the IR beacon is to the left of the robot
	else
	{
		//Use encoders to get the robot close to the box
		nMotorEncoder[rightMotor]=0;

		while(nMotorEncoder[rightMotor] < 4500)
		{
			//Constantly adjust to keep the IR beacon in line with the robot
			if(SensorValue[IRSeeker] < targetIR && SensorValue[IRSeeker] != 0)
			{
				//Turn left
				motor[leftMotor] =   -50;
				motor[rightMotor] = 50;
			}

			else if(SensorValue[IRSeeker] > targetIR)
			{
				//Turn right
				motor[leftMotor] = 50;
				motor[rightMotor] = -50;
			}

			else if (SensorValue[IRSeeker] == targetIR)
			{
				motor[leftMotor] = 60;
				motor[rightMotor]= 60;
			}

			else
			{
				// Find the beacon
				while(SensorValue[IRSeeker] == 0)
				{
					motor[leftMotor]  =  100;
					motor[rightMotor] = -100;
				}
				motor[rightMotor] =  0;
				motor[leftMotor]  =  0;
			}
		}
	}

	motor[leftMotor] = 0;
	motor[rightMotor] = 0;

	//Step 8
	//Score object

	//Finally, release the object into the box (score 40 points)
	motor[gripperMotor]= - 50;
	wait1Msec(1000);
}
#pragma config(Sensor, S1,     touch,          sensorTouch)
#pragma config(Sensor, S2,     gyro,           sensorI2CHiTechnicGyro)
#pragma config(Sensor, S3,     light,          sensorLightActive)
#pragma config(Sensor, S4,     sonar,          sensorSONAR)
#pragma config(Motor,  motorA,          gripperMotor,  tmotorNXT, openLoop, encoder)
#pragma config(Motor,  motorB,          rightMotor,    tmotorNXT, openLoop, encoder)
#pragma config(Motor,  motorC,          leftMotor,     tmotorNXT, openLoop, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard                !!*//
// This is for the NXT model, not TETRIX

/************************************\
|*  Robot Virtual World Template    *|
|*                                  *|
|*  DO NOT OVERWRITE THIS FILE      *|
|*  MAKE SURE TO "SAVE AS" INSTEAD  *|
\************************************/

task main()
{

	// your code goes here

}
