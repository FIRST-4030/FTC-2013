#pragma config(Hubs,  S1, HTMotor,  HTMotor,  none,     none)
#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTMotor,  HTMotor)
#pragma config(Hubs,  S3, HTServo,  HTServo,  none,     none)
#pragma config(Sensor, S1,     motors,         sensorNone)
#pragma config(Sensor, S2,     SMUX,           sensorI2CCustom9V)
#pragma config(Sensor, S3,     servos,         sensorNone)
#pragma config(Motor,  motorA,          flagMotor,     tmotorNXT, openLoop, encoder)
#pragma config(Motor,  motorB,           ,             tmotorNXT, openLoop, encoder)
#pragma config(Motor,  motorC,           ,             tmotorNXT, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C1_1,     leftFrontMotor, tmotorTetrix, openLoop, reversed)
#pragma config(Motor,  mtr_S1_C1_2,     leftRearMotor, tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     rightFrontMotor, tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C2_2,     rightRearMotor, tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_1,     spinnerMotor,  tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     liftMotor,     tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_1,     rightWinch,    tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_2,     leftWinch,     tmotorTetrix, openLoop, reversed)
#pragma config(Servo,  srvo_S3_C1_1,    leftHook,             tServoStandard)
#pragma config(Servo,  srvo_S3_C1_2,    rightHook,            tServoStandard)
#pragma config(Servo,  srvo_S3_C1_3,    unusedS3C13,          tServoStandard)
#pragma config(Servo,  srvo_S3_C1_4,    unusedS3C14,          tServoStandard)
#pragma config(Servo,  srvo_S3_C1_5,    unusedS3C15,          tServoStandard)
#pragma config(Servo,  srvo_S3_C1_6,    unusedS3C16,          tServoStandard)
#pragma config(Servo,  srvo_S3_C2_1,    leftHopper,           tServoStandard)
#pragma config(Servo,  srvo_S3_C2_2,    rightHopper,          tServoStandard)
#pragma config(Servo,  srvo_S3_C2_3,    unusedS3C23,          tServoStandard)
#pragma config(Servo,  srvo_S3_C2_4,    unusedS3C24,          tServoStandard)
#pragma config(Servo,  srvo_S3_C2_5,    unusedS3C25,          tServoStandard)
#pragma config(Servo,  srvo_S3_C2_6,    unusedS3C26,          tServoStandard)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
#pragma debuggerWindows("joystickSimple");
#include "auto_includes.h"
#include "drive/drive_tank.c"

// Basket Encoder Distances and IR Distances //
#define B1 (3000)
#define B1IR (3200)
#define B2 (4400)
#define B2IR (4700)
#define B3 (7000)
#define B3IR (8400)
#define B4 (8600)
#define B4IR (9800)
#include "controllers/auto_testmode.c"

///// MAIN TASK /////
task main() {
	AutonomousInit();
	// Wait for the beginning of autonomous phase.
	//waitForStart();
	StartTask(Drive);
	StartTask(AutoTestControl);
	while(true)
	{
		getJoystickSettings(joystick);
		IR_out = HTIRS2readACDir(IRSeeker);
		motorEncoder_out = readDriveEncoder();
		if(joystick.joy1_TopHat == 0 || joystick.joy1_TopHat == 4)
			resetDriveEncoder();
		if(joy1Btn(9) == 1)
		{
			// Test Drive and Control Tasks //
			StopTask(Drive);
			StopTask(AutoTestControl);
			
			// IR Failover Check //
			if(IR_out < 1 || IR_out > 9)
			{
				StartTask(Drive);
				StartTask(AutoTestControl);
				continue;
			}
			
			// Drive parallel to the baskets until we are at the beacon
			resetDriveEncoder();
			while(HTIRS2readACDir(IRSeeker) != 8) // would need to be a 2 if going form the left
				runDriveMotors(FULL_IMPULSE,FULL_IMPULSE);
			stopDriveMotors();

			// Decide on correct basket based on encoder distance //
			int enVal = readDriveEncoder();
			if(enVal < (B1+B2)/2) // Decision point is between B1 and B2
			{
				if(enVal < B1)
				{
					while(readDriveEncoder() < B1)
						runDriveMotors(HALF_IMPULSE,HALF_IMPULSE);
				}
				else
				{
					while(readDriveEncoder() > B1)
						runDriveMotors(-HALF_IMPULSE,-HALF_IMPULSE);
				}
			}
			else if(enVal < ((B2+B3)/2)) // Decision point is between B2 and B3
			{
				if(enVal < B2)
				{
					while(readDriveEncoder() < B2)
						runDriveMotors(HALF_IMPULSE,HALF_IMPULSE);
				}
				else
				{
					while(readDriveEncoder() > B2)
						runDriveMotors(-HALF_IMPULSE,-HALF_IMPULSE);
				}
			}
			else if(enVal < ((B4+B3)/2)) // Decision point is between B3 and B4
			{
				if(enVal < B3)
				{
					while(readDriveEncoder() < B3)
						runDriveMotors(HALF_IMPULSE,HALF_IMPULSE);
				}
				else
				{
					while(readDriveEncoder() > B3)
						runDriveMotors(-HALF_IMPULSE,-HALF_IMPULSE);
				}
			}
			else
			{
				if(enVal < B4)
				{
					while(readDriveEncoder() < B4)
						runDriveMotors(HALF_IMPULSE,HALF_IMPULSE);
				}
				else
				{
					while(readDriveEncoder() > B4)
						runDriveMotors(-HALF_IMPULSE,-HALF_IMPULSE);
				}
			}
			stopDriveMotors();

			// Raise Lift //
			RaiseLift();
			resetDriveEncoder();
			
			// @Zach: reverse turn function was not working
			// Turn Right 90 Degrees //
			while(readDriveEncoder() > -3000)
				runDriveMotors(HALF_IMPULSE,-HALF_IMPULSE);
			stopDriveMotors();
			
			// Drop Brick //
			SetHopperServos(HOPPER_MIN);
			wait1Msec(1000);
			
			// Put Away Hopper //
			SetHopperServos(HOPPER_MAX);
			
			// Lower Lift //
			MoveLift(true);

			// Return to base
			//FlagLine_ReturnFromBasket(SonarBeforeBasketApproach);
			StartTask(Drive);
			StartTask(AutoTestControl);
		}
	}
}
