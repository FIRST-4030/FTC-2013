#pragma config(Hubs,  S1, HTMotor,  HTMotor,  none,     none)
#pragma config(Sensor, S2,     SMUX,           sensorI2CCustom9V)
#pragma config(Motor,  motorA,          gripperMotor,  tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C1_1,     rightMotor,    tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     leftMotor,     tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     flagMotor,     tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C2_2,     spinnerMotor,  tmotorTetrix, openLoop, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
///// Includes /////
#pragma debuggerWindows("joystickSimple");
#include "../drivers/hitechnic-sensormux.h"
#include "../drivers/hitechnic-irseeker-v2.h"
#include "../drivers/lego-ultrasound.h"
#include "../drivers/lego-touch.h"
#include "../drivers/lego-light.h"
#include "../sensors/colors.c"
#include "../Motors/motors.c"
#include "../Drive/lines.c"
#include "../Drive/drive.c"
#include "JoystickDriver.c"  //Include file to "handle" the Bluetooth messages.

///// Sensor Multiplexer Interface /////
const tMUXSensor sonar = msensor_S2_1;
const tMUXSensor IRSeeker = msensor_S2_2;
const tMUXSensor lightRight = msensor_S2_3;
const tMUXSensor lightLeft = msensor_S2_4;

///// CONSTANTS /////
#define BLIPS_PER_INCH (1440.0 / 12.6)
#define INCH_PER_BLIPS (12.6 / 1440.0)
#define FULL_IMPULSE (100)
#define HALF_IMPULSE (50)
#define QUARTER_IMPULSE (25)
#define EIGHTH_IMPULSE (12)
#define WALL_TO_MID (3000)

int motorEncoder_out = 0;
int motorEncoder_inches = 0;
int B2I(int x)
{
	return x / BLIPS_PER_INCH;
}
int I2B(int x)
{
	return x * INCH_PER_BLIPS;
}

void FlashLights(int times, int delay)
{
	for(int i=0; i<times; i++)
	{
		LSsetInactive(lightRight);
	  LSsetInactive(lightLeft);
		wait1Msec(delay);
	  LSsetActive(lightRight);
  	LSsetActive(lightLeft);
		wait1Msec(delay);
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//                                    initializeRobot
// Prior to the start of autonomous mode, you may want to perform some initialization on your robot.
/////////////////////////////////////////////////////////////////////////////////////////////////////
void initializeRobot() {
	// Initialize the sensor and motor configuration
	setLightSensorHeight(5.0);
	setDriveMotors(leftMotor, rightMotor);
	setLineSensors(lightLeft, lightRight);

	// Initialize Motor Encoders //
	resetDriveEncoder();

	// Stop All Motors //
	stopDriveMotors();
	motor[spinnerMotor] = 0;

	// Cycle Light Sensor Lights //
	// Indicates Initialization Complete //
	FlashLights(5,50);
	return;
}

void InsideLeftTurn(bool reverse)
{
	if(reverse == false)
		driveMotors(-FULL_IMPULSE,0.35*FULL_IMPULSE,-1);
	else
		driveMotors(FULL_IMPULSE,0,-1);
}
void OutsideLeftTurn(bool reverse)
{
	if(reverse == false)
		driveMotors(-QUARTER_IMPULSE,HALF_IMPULSE,-1);
	else
		driveMotors(HALF_IMPULSE,-HALF_IMPULSE,-1);
}

void FollowLine(int lineColor)
{
	if(LSvalRaw(lightLeft) > lineColor)
		driveMotors(0,QUARTER_IMPULSE,-1);
	else if(LSvalRaw(lightRight) > lineColor)
		driveMotors(QUARTER_IMPULSE,0,-1);
	else
		driveMotors(QUARTER_IMPULSE,QUARTER_IMPULSE,-1);
}

void Wait() {
	wait1Msec(10000);
}

//////////////////////////////
//				DRIVE TASK			  //
//////////////////////////////
task Drive() {
	int threshold = 10;
	while(true)
	{
		getJoystickSettings(joystick);
		if(abs(joystick.joy1_y1) > threshold)
			motor[leftMotor] = joystick.joy1_y1;
		else
			motor[leftMotor] = 0;
		if(abs(joystick.joy1_y2) > threshold)
			motor[rightMotor] = joystick.joy1_y2;
		else
			motor[rightMotor] = 0;
	}
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                         AUTONOMOUS
//
/////////////////////////////////////////////////////////////////////////////////////////////////////
// Start the robot with the back right wheel touching the wall and the right wheels lined up with the flag line.
// Face the robot along the flag line.
void OnFlagLineRightCorner_Basket()  //Add a bool variable that can be passed and call Wait?
{
	//Would initiate Wait, could set whether or not to wait at beginning
	/*
	if(bool wait = true)
	{
		Wait();
	}*/
	if(HTIRS2readACDir(IRSeeker) != 0)
	{
		nMotorEncoder[leftMotor] = 0;
		int startTurn = 8; // IRSeeker indicates far left
		while(HTIRS2readACDir(IRSeeker) < startTurn )
			driveMotors(HALF_IMPULSE, HALF_IMPULSE, -1);

		int encoderAtTurn = nMotorEncoder[leftMotor];
		motorEncoder_out = nMotorEncoder[leftMotor];
		int stopTurn = 5;
		if(nMotorEncoder[leftMotor] < WALL_TO_MID)
		{
			//Take Inside Left Turn //
			while(HTIRS2readACDir(IRSeeker) != stopTurn)
				OutsideLeftTurn(false);
	  }
		else
		{
			//Take Outside Left Turn //
			while(HTIRS2readACDir(IRSeeker) != stopTurn)
				InsideLeftTurn(false);
		}

		///// PLACEHOLDER FOR DUMPING ROUTINE /////
		driveMotors(0,0,-1);
		FlashLights(5,50);
		///////////////////////////////////////////

		// Return to Starting Point //
		while(HTIRS2readACDir(IRSeeker) != startTurn)
		{
			if(encoderAtTurn < 3000)
				OutsideLeftTurn(true);
			else
				InsideLeftTurn(true);
		}
		while(nMotorEncoder[leftMotor] > 0)
			driveMotors(-HALF_IMPULSE,-HALF_IMPULSE,-1);

		driveMotors(0,0,-1);
	}
}
// Start Same as OnFlagLineRightCorner_Basket //
// Turns, finds line, follows line up on ramp and stops //
void OnFlagLineRightCorner_Ramp(bool reverse = false) {
	// Turn Left Dead Reckoning //
	if(reverse)
		driveMotors(HALF_IMPULSE,-1 * HALF_IMPULSE, 850);
	else
		driveMotors(-1 * HALF_IMPULSE, HALF_IMPULSE, 850);

	// Forward to white line
	driveToColor(WHITE, QUARTER_IMPULSE);

	// Align with white line
	alignLine(WHITE, QUARTER_IMPULSE, reverse);

	// Follow line to ramp
	followLineToColor(WHITE, HALF_IMPULSE, BLACK);

	// Rear Light Sensor is Mounted about 2" in front of wheels //
	driveMotors(FULL_IMPULSE,FULL_IMPULSE,100);

}
/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                         Main Task
//
/////////////////////////////////////////////////////////////////////////////////////////////////////
void CalibrateColors()
{
	FlashLights(3,250);
	getJoystickSettings(joystick);
	while(joy1Btn(10) != 1)
	{
		// black // A
		if(joy1Btn(2) == 1)
		{
			COLORS[BLACK].min = LSvalRaw(lightLeft)-10;
			COLORS[BLACK].max = LSvalRaw(lightRight)+10;
			FlashLights(2,250);
		}
		// white // Y
		if(joy1Btn(4) == 1)
		{
			COLORS[WHITE].min = LSvalRaw(lightLeft)-10;
			COLORS[WHITE].max = LSvalRaw(lightRight)+10;
			FlashLights(2,250);
		}
		// red // B
		if(joy1Btn(3) == 1)
		{
			COLORS[RED].min = LSvalRaw(lightLeft)-10;
			COLORS[RED].max = LSvalRaw(lightRight)+10;
			FlashLights(2,250);
		}
		// blue // X
		if(joy1Btn(1) == 1)
		{
			COLORS[BLUE].min = LSvalRaw(lightLeft)-10;
			COLORS[BLUE].max = LSvalRaw(lightRight)+10;
			FlashLights(2,250);
		}
	}
	// gray // start
	COLORS[GREY].min = LSvalRaw(lightLeft)-10;
	COLORS[GREY].max = LSvalRaw(lightRight)+10;
	FlashLights(3,250);
}

task main()
{
  initializeRobot();
  //waitForStart(); // Wait for the beginning of autonomous phase.

  StartTask(Drive); // Allows control of robot between scenarios //

  while(true)
	{
		getJoystickSettings(joystick);
		IR_out = HTIRS2readACDir(IRSeeker);
		Sonar_out = USreadDist(sonar);
		LightRight_out = LSvalRaw(lightRight);
		LightLeft_out = LSvalRaw(lightLeft);
		motorEncoder_out = nMotorEncoder[leftMotor];
		motorEncoder_inches = B2I(motorEncoder_out);

		// Basket Routine Only //
		if(joystick.joy1_TopHat == 1) // top-hat UP
		{
			StopTask(Drive);
			OnFlagLineRightCorner_Basket();
			StartTask(Drive);
			FlashLights(2,250);
		}

		// Ramp Routine Only //
		if(joystick.joy1_TopHat == 4) // top-hat DOWN
		{
			StopTask(Drive);
			OnFlagLineRightCorner_Ramp();
			StartTask(Drive);
			FlashLights(2,250);
		}

		// Run Full Autonomous Routine //
		if(joystick.joy1_TopHat == 2) // top-hat RIGHT
		{
			StopTask(Drive);
			OnFlagLineRightCorner_Ramp(true);
			StartTask(Drive);
			FlashLights(2,250);
		}

		if(joy1Btn(9) == 1) // Back button
			nMotorEncoder[leftMotor] = 0;

//		if(joy1Btn(10) == 1) // Start Button // Reinitialize Robot //
	//		initializeRobot();

		if(joy1Btn(12) == 1) // Right Joystick Button
			CalibrateColors();
	}
}
