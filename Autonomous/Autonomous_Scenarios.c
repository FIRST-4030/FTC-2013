#pragma config(Hubs,  S1, HTMotor,  HTMotor,  none,     none)
#pragma config(Sensor, S2,     SMUX,           sensorI2CCustom9V)
#pragma config(Motor,  motorA,          gripperMotor,  tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C1_1,     rightMotor,    tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     leftMotor,     tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     flagMotor,     tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C2_2,     spinnerMotor,  tmotorTetrix, openLoop, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
///// Includes /////
#pragma debuggerWindows("joystickSimple");
#include "../drivers/hitechnic-sensormux.h"
#include "../drivers/hitechnic-irseeker-v2.h"
#include "../drivers/lego-ultrasound.h"
#include "../drivers/lego-touch.h"
#include "../drivers/lego-light.h"
#include "JoystickDriver.c"  //Include file to "handle" the Bluetooth messages.

///// Sensor Multiplexer Interface /////
const tMUXSensor sonar = msensor_S2_1;
const tMUXSensor IRSeeker = msensor_S2_2;
const tMUXSensor lightRight = msensor_S2_3;
const tMUXSensor lightLeft = msensor_S2_4;

///// CONSTANTS /////
#define BLIPS_PER_INCH (1440.0 / 12.6)
#define INCH_PER_BLIPS (12.6 / 1440.0)
#define FULL_IMPULSE (100)
#define HALF_IMPULSE (50)
#define QUARTER_IMPULSE (25)
#define EIGHTH_IMPULSE (12)

int IR_out = 0;
int Sonar_out = 0;
int LightRight_out = 0;
int LightLeft_out = 0;
int motorEncoder_out = 0;
int motorEncoder_inches = 0;
int B2I(int x)
{
	return x / BLIPS_PER_INCH;
}
int I2B(int x)
{
	return x * INCH_PER_BLIPS;
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                    initializeRobot
//
// Prior to the start of autonomous mode, you may want to perform some initialization on your robot.
// Things that might be performed during initialization include:
//   1. Move motors and servos to a preset position.
//   2. Some sensor types take a short while to reach stable values during which time it is best that
//      robot is not moving. For example, gyro sensor needs a few seconds to obtain the background
//      "bias" value.
//
// In many cases, you may not have to add any code to this function and it will remain "empty".
//
/////////////////////////////////////////////////////////////////////////////////////////////////////
void initializeRobot()
{
  // Place code here to initialize servos to starting positions.
  // Sensors are automatically configured and setup by ROBOTC. They may need a brief time to stabilize.

	// Turn Light Sensor Light On //
  LSsetActive(lightRight);
  LSsetActive(lightLeft);

	// Initialize Motor Encoders //
	nMotorEncoder[leftMotor] = 0;

	// Stop All Motors //
	motor[leftMotor] = 0;
	motor[rightMotor] = 0;
	motor[spinnerMotor] = 0;

	wait1Msec(1000);
  return;
}

void driveMotors(int powLeft, int powRight, const int nTime)
{
  motor[rightMotor] =  powRight;
  motor[leftMotor]  =  powLeft;
  if(nTime >=0)
  	wait1Msec(nTime);
}

//basket path
void goToBasket(int nBasket)
{
	if(nBasket == 3)          // LL
		{
			driveMotors(0,75,1500);
		}
		else if(nBasket == 4)     // Left
		{
			driveMotors(50,75,1000);
		}
		else if(nBasket == 5)     // Right
		{
			driveMotors(75,50,1000);
		}
		else if (nBasket == 6)		// RR
		{
			driveMotors(75,0,1500);
		}

}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                         AUTONOMOUS SCENARIOS
//
/////////////////////////////////////////////////////////////////////////////////////////////////////
// Start the robot with the right side flush with the wall.
// Face the robot towards the flag.
void OnWallFacingFlag()
{
	int firstTurn = 80; // distance to wall of ~32"
	while(USreadDist(sonar) > firstTurn )
		driveMotors(HALF_IMPULSE, HALF_IMPULSE, -1);

	// Left Turn //
	int stopLeftTurn = 5;
	while(HTIRS2readACDir(IRSeeker) != stopLeftTurn)
		driveMotors(-HALF_IMPULSE, HALF_IMPULSE, -1);

	// Approach Basket //
	while(USreadDist(sonar) > 50) // && LSvalRaw(lightLeft) > 40) Light sensors need recalibrated with SMUX
		driveMotors(QUARTER_IMPULSE, QUARTER_IMPULSE, -1);

	driveMotors(0,0,-1);
}

// Start the robot with the back right wheel touching the wall and the right wheels lined up with the flag line.
// Face the robot along the flag line.
void OnFlagLineRightCorner()
{
	nMotorEncoder[leftMotor] = 0;
	int firstTurn = 8; // IRSeeker indicates far left
	while(HTIRS2readACDir(IRSeeker) < firstTurn )
		driveMotors(HALF_IMPULSE, HALF_IMPULSE, -1);

	motorEncoder_out = nMotorEncoder[leftMotor];
	motorEncoder_inches = B2I(motorEncoder_out);

	if(nMotorEncoder[leftMotor] < 3000)
	{
		//Take Inside Left Turn //
		int stopLeftTurn = 5;
		while(HTIRS2readACDir(IRSeeker) != stopLeftTurn)
			driveMotors(-HALF_IMPULSE, 0, -1);
  }
	else
	{
		//Take Outside Left Turn //
		int stopLeftTurn = 5;
		while(HTIRS2readACDir(IRSeeker) != stopLeftTurn)
			driveMotors(-QUARTER_IMPULSE, HALF_IMPULSE, -1);
	}

	// Stop Motors //
	driveMotors(0,0,-1);
}

void CeaseAndDesist()
{
	StopAllTasks();
	initializeRobot();
}

/////////////////////////////////////////////////////////////////////////////////////////////////////
//
//                                         Main Task
//
// The following is the main code for the autonomous robot operation. Customize as appropriate for
// your specific robot.
//
// The types of things you might do during the autonomous phase (for the 2008-9 FTC competition)
// are:
//
//   1. Have the robot follow a line on the game field until it reaches one of the puck storage
//      areas.
//   2. Load pucks into the robot from the storage bin.
//   3. Stop the robot and wait for autonomous phase to end.
//
// This simple template does nothing except play a periodic tone every few seconds.
//
// At the end of the autonomous period, the FMS will autonmatically abort (stop) execution of the program.
//
/////////////////////////////////////////////////////////////////////////////////////////////////////
task main()
{
  initializeRobot();
  //waitForStart(); // Wait for the beginning of autonomous phase.

  while(true)
	{
		getJoystickSettings(joystick);
		IR_out = HTIRS2readACDir(IRSeeker);
		Sonar_out = USreadDist(sonar);
		LightRight_out = LSvalRaw(lightRight);
		LightLeft_out = LSvalRaw(lightLeft);
		motorEncoder_out = nMotorEncoder[leftMotor];
		motorEncoder_inches = B2I(motorEncoder_out);

		// Start: Right side on wall with front of robot facing flag.
		if(joy1Btn(1) == 1) // X //
			OnWallFacingFlag();

		// Start: right wheels aligned with flag line. Back right wheel touching wall.
		if(joy1Btn(2) == 1) // A //
			OnFlagLineRightCorner();

		if(joy1Btn(10) == 1) // start button //
			CeaseAndDesist();
	}
  //lined up and ready to find IR sensor
  //	goToBasket(SensorValue[IRSeeker]);
}


//direction functions

//not needed?
void goForward(const int nTime)
{
  motor[leftMotor]  = 75;
  motor[rightMotor] = 75;
  if(nTime >=0)
  	wait1Msec(nTime);
}

void turnRight(const int nTime)
{
  motor[leftMotor]  = 75;
  motor[rightMotor] =  0;
  if(nTime >=0)
  	wait1Msec(nTime);
}

void turnLeft(const int nTime)
{
  motor[leftMotor]  =  0;
  motor[rightMotor] = 75;
  if(nTime >=0)
  	wait1Msec(nTime);
}

void goBackwards(const int nTime)
{
  motor[leftMotor]  = -75;
  motor[rightMotor] = -75;
  if(nTime >=0)
  	wait1Msec(nTime);
}
